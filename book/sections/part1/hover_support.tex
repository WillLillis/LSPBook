The time is now! We're finally adding a real feature to our LSP! We'll start by adding hover support for instructions. A few things need to happen first though, before we see that sweet sweet hover documentation window. First we need some source of information for our instructions. This source needs to be in a fairly organized, regular format fit for parsing. After finding such a source, we then need to write some code to parse and load it into our program. This will require some parsing code (duh), as well as some data structures to represent our information once it's loaded from disk. Finally, we need to trigger every time a hover request comes in from the client, check our relevant data structures, and return any results we find in the right format. Without further ado, let's get started.

\subsection{Finding an Information Source}

The first thing we need is find some kind of data source for the x86\_64 instructions. It should be well organized, reasonably convertible to some in-memory data structure, and hopefully actively maintained (many active assembly languages receive regular updates). Lucky for us, such a data source already exists! The open source \href{https://github.com/Maratyszcza/Opcodes}{Opcodes} repo conveniently has both the x86 and x86\_64 instruction sets in an xml file. Let's pull the appropriate file into our project:

\begin{lstlisting}[language=bash]
mkdir opcodes && cd opcodes
curl https://github.com/Maratyszcza/Opcodes/blob/master/opcodes/x86.xml --output x86.xml
\end{lstlisting}

Our project should look two directories now (ignoring the \texttt{target} build directory).

\lstset{escapeinside={<@}{@>}}
\begin{lstlisting}
<@\textcolor{blue}{assembly-lsp}@>
|--Cargo.lock
|--Cargo.toml
|--<@\textcolor{blue}{opcodes}@>
|  |--x86.xml
|--<@\textcolor{blue}{src}@>
   |--main.rs
\end{lstlisting}

Let's take a look inside that new file!

\begin{lstlisting}[language=xml]
<?xml version='1.0' encoding='utf-8'?>
<InstructionSet name="x86">
  <Instruction name="AAA" summary="ASCII Adjust After Addition">
    <InstructionForm gas-name="aaa" go-name="AAA">
      <Encoding>
        <Opcode byte="37"/>
      </Encoding>
    </InstructionForm>
  </Instruction>
  <Instruction name="AAD" summary="ASCII Adjust AX Before Division">
    <InstructionForm gas-name="aad" go-name="AAD">
      <Encoding>
        <Opcode byte="D5"/>
        <Opcode byte="0A"/>
      </Encoding>
    </InstructionForm>
    <InstructionForm gas-name="aad" go-name="AAD">
      <Operand type="imm8"/>
      <Encoding>
        <Opcode byte="D5"/>
        <Immediate size="1" value="#0"/>
      </Encoding>
    </InstructionForm>
  </Instruction>
  <Instruction name="AADD" summary="Atomically ADD">
  ...
\end{lstlisting}

It looks like each instruction has its name stored along with a short summary. Nested inside each \texttt{<Instruction ...} there also appears to be one or more instruction forms for the GNU Assembler (GAS) or the Go Assembler. Each form has some more information included, such as the opcodes for that form, the different arguments it can take, etc. How are we going to represent this data inside our program?

\subsection{Data Structures and Parsing}

This calls for a new file! Let's create \texttt{src/instruction.rs} and start laying out our data. Here's a start...

\begin{lstlisting}[language=rust]
pub struct Instruction {
    name: String,
    summary: String,
    ...
}
\end{lstlisting}

Those instruction forms seem fairly important, so let's create a struct to represent them and then store a vector of forms inside each instruction. Given that there are opcode files for both x86 and x86\_64, we should probably put some kind of architecture information in there as well. Finally, we'll also derive some common methods on these to make our lives easier down the road.

\begin{lstlisting}[language=rust]
#[derive(Debug, Clone, Default)]
pub struct Instruction {
    pub name: String,
    pub summary: String,
    pub arch: Option<Arch>,
    pub forms: Vec<InstructionForm>,
}

#[derive(Debug, Clone, Default)]
pub struct InstructionForm {
    pub gas_name: Option<String>,
    pub go_name: Option<String>,
    pub encoding: String,
    pub operands: Vec<Operand>
}

#[derive(Debug, Clone)]
pub struct Operand {
    pub op_type: OperandType,
    pub input: bool,
    pub output: bool,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy)]
pub enum Arch {
    x86,
    x86_64,
}
\end{lstlisting}

Writing out all of the variants for the \texttt{OperandType} enum looks really annoying and tedious...luckily I've done it for you! For the sake of brevity, I'll also take this time to introduce some new crates (\texttt{cargo add strum} and \texttt{cargo add strum\_macros} when you have a minutes) to our project. We'll use these dependencies to great effect while parsing and deserializing the \texttt{x86.xml} file. Some operand types conflict with Rust's naming rules for its enum variants, so in those cases I've changed the variant name to something reasonably close, and then included the \texttt{\#[strum(serialize = "<ActualOpTypeHere>")]} macro to make the translation possible. We'll also apply these helpers to our \texttt{Arch} enum.

\begin{lstlisting}[language=rust]
use strum_macros::{AsRefStr, EnumString};

...

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, EnumString, AsRefStr, Default)]
pub enum Arch {
    #[default]
    x86,
    x86_64,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, EnumString, AsRefStr)]
pub enum OperandType {
    #[strum(serialize = "1")]
    _1,
    #[strum(serialize = "3")]
    _3,
    imm4,
    imm8,
    imm16,
    imm32,
    imm64,
    al,
    cl,
    r8,
    r8l,
    ax,
    r16,
    r16l,
    eax,
    r32,
    r32l,
    rax,
    r64,
    mm,
    xmm0,
    xmm,
    #[strum(serialize = "xmm{k}")]
    xmm_k,
    #[strum(serialize = "xmm{k}{z}")]
    xmm_k_z,
    ymm,
    #[strum(serialize = "ymm{k}")]
    ymm_k,
    #[strum(serialize = "ymm{k}{z}")]
    ymm_k_z,
    zmm,
    #[strum(serialize = "zmm{k}")]
    zmm_k,
    #[strum(serialize = "zmm{k}{z}")]
    zmm_k_z,
    k,
    #[strum(serialize = "k{k}")]
    k_k,
    moffs32,
    moffs64,
    m,
    m8,
    m16,
    #[strum(serialize = "m16{k}")]
    m16_k,
    #[strum(serialize = "m16{k}{z}")]
    m16_k_z,
    m32,
    #[strum(serialize = "m32{k}")]
    m32_k,
    #[strum(serialize = "m32{k}{z}")]
    m32_k_z,
    #[strum(serialize = "m32/m16bcst")]
    m32_m16bcst,
    m64,
    #[strum(serialize = "m64{k}")]
    m64_k,
    #[strum(serialize = "m64{k}{z}")]
    m64_k_z,
    #[strum(serialize = "m64/m16bcst")]
    m64_m16bcst,
    m128,
    #[strum(serialize = "m128{k}")]
    m128_k,
    #[strum(serialize = "m128{k}{z}")]
    m128_k_z,
    m256,
    #[strum(serialize = "m256{k}")]
    m256_k,
    #[strum(serialize = "m256{k}{z}")]
    m256_k_z,
    m512,
    #[strum(serialize = "m512{k}")]
    m512_k,
    #[strum(serialize = "m512{k}{z}")]
    m512_k_z,
    #[strum(serialize = "m64/m32bcst")]
    m64_m32bcst,
    #[strum(serialize = "m128/m32bcst")]
    m128_m32bcst,
    #[strum(serialize = "m256/m32bcst")]
    m256_m32bcst,
    #[strum(serialize = "m512/m32bcst")]
    m512_m32bcst,
    #[strum(serialize = "m128/m16bcst")]
    m128_m16bcst,
    #[strum(serialize = "m128/m64bcst")]
    m128_m64bcst,
    #[strum(serialize = "m256/m16bcst")]
    m256_m16bcst,
    #[strum(serialize = "m256/m64bcst")]
    m256_m64bcst,
    #[strum(serialize = "m512/m16bcst")]
    m512_m16bcst,
    #[strum(serialize = "m512/m64bcst")]
    m512_m64bcst,
    vm32x,
    #[strum(serialize = "vm32x{k}")]
    vm32x_k,
    vm64x,
    #[strum(serialize = "vm64x{k}")]
    vm64xk,
    vm32y,
    #[strum(serialize = "vm32y{k}")]
    vm32yk_,
    vm64y,
    #[strum(serialize = "vm64y{k}")]
    vm64y_k,
    vm32z,
    #[strum(serialize = "vm32z{k}")]
    vm32z_k,
    vm64z,
    #[strum(serialize = "vm64z{k}")]
    vm64z_k,
    rel8,
    rel32,
    #[strum(serialize = "{er}")]
    er,
    #[strum(serialize = "{sae}")]
    sae,
    sibmem,
    tmm, 
}
\end{lstlisting}

\subsection{Information Loading}

Great! Now we have a bunch of data in our xml file, and we have some places to put all that data with our above data structures! Now we just need to actually \textit{put} the data in the structs. Again, we're focusing on LSPs here! I'll spare the reader from what would have most certainly been an eloquent, flowing explanation and instead present the code with a brief explanation after. We'll add a new dependency with \texttt{cargo add quick-xml}, and then start with a fresh file \texttt{src/populate.rs}, we have...

\begin{lstlisting}[language=rust]
/* src/populate.rs */
use crate::instruction::{Operand, OperandType, Instruction, InstructionForm};
use std::collections::HashMap;

use std::str;
use std::str::FromStr;

use quick_xml::events::attributes::Attribute;
use quick_xml::events::Event;
use quick_xml::name::QName;
use quick_xml::Reader;

use anyhow::anyhow;
use log::debug;

/// Takes xml file contents and converts it into a Vec<Instruction>
pub fn populate_instructions(xml_contents: &str) -> anyhow::Result<HashMap<String, Instruction>> {
    let mut instructions_map = HashMap::<String, Instruction>::new();

    let mut reader = Reader::from_str(xml_contents);
    reader.trim_text(true);

    // instruction and instruction form that are currently under construction
    let mut curr_instruction = Instruction::default();
    let mut curr_instruction_form = InstructionForm::default();

    debug!("Parsing XML contents...");
    loop {
        match reader.read_event() {
            // start event ------------------------------------------------------------------------
            Ok(Event::Start(ref e)) => {
                match e.name() {
                    QName(b"Instruction") => {
                        // start of a new instruction
                        curr_instruction = Instruction::default();

                        // iterate over the attributes
                        for attr in e.attributes() {
                            let Attribute { key, value } = attr.unwrap();
                            match str::from_utf8(key.into_inner()).unwrap() {
                                "name" => unsafe {
                                    let name = String::from(str::from_utf8_unchecked(&value).to_lowercase());
                                    curr_instruction.name = name;
                                },
                                "summary" => unsafe {
                                    curr_instruction.summary =
                                        String::from(str::from_utf8_unchecked(&value));
                                },
                                _ => {}
                            }
                        }
                    }
                    QName(b"InstructionForm") => {
                        // new instruction form 
                        curr_instruction_form = InstructionForm::default();

                        // iterate over the attributes
                        for attr in e.attributes() {
                            let Attribute { key, value } = attr.unwrap();
                            match str::from_utf8(key.into_inner()).unwrap() {
                                "gas-name" => unsafe {
                                    curr_instruction_form.gas_name =
                                        Some(String::from(str::from_utf8_unchecked(&value).to_lowercase()));
                                },
                                "go-name" => unsafe {
                                    curr_instruction_form.go_name =
                                        Some(String::from(str::from_utf8_unchecked(&value).to_lowercase()));
                                },
                                _ => {}
                            }
                        }
                    }
                    QName(b"Encoding") => {} // TODO
                    _ => (),                 // unknown event
                }
            }
            Ok(Event::Empty(ref e)) => {
                match e.name() {
                    QName(b"Operand") => {
                        let mut op_type = OperandType::k; // dummy initialisation
                        let mut input = None;
                        let mut output = None;

                        for attr in e.attributes() {
                            let Attribute { key, value } = attr.unwrap();
                            match str::from_utf8(key.into_inner()).unwrap() {
                                "type" => {
                                    op_type = match OperandType::from_str(str::from_utf8(&value)?) {
                                        Ok(op_type) => op_type,
                                        Err(_) => {
                                            return Err(anyhow!(
                                                "Unknown value for operand type -- Variant: {}",
                                                str::from_utf8(&value)?
                                            ));
                                        }
                                    }
                                }
                                "input" => match str::from_utf8(&value).unwrap() {
                                    "true" => input = Some(true),
                                    "false" => input = Some(false),
                                    _ => return Err(anyhow!("Unknown value for operand type")),
                                },
                                "output" => match str::from_utf8(&value).unwrap() {
                                    "true" => output = Some(true),
                                    "false" => output = Some(false),
                                    _ => return Err(anyhow!("Unknown value for operand type")),
                                },
                                _ => (), // unknown event
                            }
                        }

                        curr_instruction_form.operands.push(Operand {
                            op_type,
                            input,
                            output,
                        })
                    }
                    _ => (), // unknown event
                }
            }
            // end event --------------------------------------------------------------------------
            Ok(Event::End(ref e)) => {
                match e.name() {
                    QName(b"Instruction") => {
                        // finish instruction
                        instructions_map
                            .insert(curr_instruction.name.clone(), curr_instruction.clone());
                    }
                    QName(b"InstructionForm") => {
                        curr_instruction.forms.push(curr_instruction_form.clone());
                    }
                    _ => (), // unknown event
                }
            }
            Ok(Event::Eof) => break,
            Err(e) => panic!("Error at position {}: {:?}", reader.buffer_position(), e),
            _ => (), // rest of events that we don't consider
        }
    }

    Ok(instructions_map)
}
\end{lstlisting}

This is a fair amount of code, but most of it is fairly straightforward. The \texttt{quick-xml} crate allows for event-based reading. Each opening \texttt{<Instruction name=``...} goes right along with an \texttt{Event::Start()} with the reader. Similarly, each closing \texttt{</Instruction>} pairs with a corresponding \texttt{Event::End()}. The qualified name (\texttt{QName()}) allows us to distinguish between events for \texttt{Instruction}s, \texttt{InstructionForm}s, and other pieces of information. A new \texttt{Instruction} struct is created with each starting event, its fields are filled in, and the struct is moved into a \texttt{HashMap} on a closing event. The same goes for \texttt{InstructionForm}s, except on close the form is appended to the current \texttt{Instruction}'s \texttt{forms} field.

Those who gave the code a quick glance may have noticed the alarming amount of \texttt{unsafe\{\}} blocks the code uses. Isn't unsafe code bad? Aren't we risking frequent crashes and an unreliable end product? Well, not really. This piece of code runs once (maybe a handful of times once we get further into the project) at startup and that's it. The function's input (our xml file) will rarely or never change. Once everything is working today, we can rest assured that it will also work tomorrow. We could \textit{definitely} write this without any \texttt{unsafe\{\}} blocks by simply replacing  \texttt{str::from\_utf8\_unchecked()} with \texttt{str::from\_utf8()} and handling any errors appropriately. Using the unchecked variant gives a performance boost, however, as the code doesn't check to make sure that the string contains valid UTF-8 first. This boost translates into our server reaching full-functionality faster after starting, which will translate directly into a better user experience. I took the time to measure the two (which you should do for \textit{any} performance work!) and found a definite, albeit small performance boost for the unsafe version. Given that it adds little to no extra complexity, we'll take it!

Potentially dubious performance claims aside, let's continue! Let's take that code we just wrote and put it to use. We'll call this new function in our \texttt{main()} function, and then pass the resulting map to \texttt{main\_loop()} to service requests.

\begin{lstlisting}[language=rust]
/* src/main.rs */
use std::collections::HashMap;

use assembly_lsp::{instruction::Instruction, populate::populate_instructions};

fn main() -> anyhow::Result<()> {
    ...

    let initialization_params = connection.initialize(server_capabilities)?;

    info!("Populating instruction set -> x86...");
    let xml_conts_x86 = include_str!("../opcodes/x86.xml");
    let x86_instrs = populate_instructions(xml_conts_x86)?;

    main_loop(connection, initialization_params, x86_instrs)?;
    io_threads.join()?;

    // Shut down gracefully.
    info!("Shutting down assembly-lsp");
    Ok(())
}

fn main_loop(
    connection: Connection,
    params: serde_json::Value,
    x86_instrs: HashMap<String, Instruction>,
) -> anyhow::Result<()> {
    let _params: InitializeParams = serde_json::from_value(params).unwrap();
    info!("Entering main loop");
    for msg in &connection.receiver {
        info!("got msg: {msg:?}");
        match msg {
            Message::Request(req) => {
                if connection.handle_shutdown(&req)? {
                    return Ok(());
                }
                info!("Got request: {req:?}");
            }
            Message::Response(resp) => {
                info!("Got response: {resp:?}");
            }
            Message::Notification(notif) => {
                info!("Got notification: {notif:?}");
            }
        }
    }
    Ok(())
}
\end{lstlisting}

\subsection{Hover Requests}

We're almost there! Our next step is to connect our instruction information in the map and incoming hover requests from our editor. Our first step is to recognize when we're receiving a hover request:

\begin{lstlisting}[language=rust]
/* src/main.rs */
fn main_loop(
    connection: Connection,
    params: serde_json::Value,
    x86_instrs: HashMap<String, Instruction>,
) -> anyhow::Result<()> {
    let _params: InitializeParams = serde_json::from_value(params).unwrap();
    info!("Entering main loop");
    for msg in &connection.receiver {
        info!("got msg: {msg:?}");
        match msg {
            Message::Request(req) => {
                if connection.handle_shutdown(&req)? {
                    return Ok(());
                }
                info!("Got request: {req:?}");
                if let Ok((id, params)) = cast_req::<HoverRequest>(req) {
                    info!("{:?}", params);
                    //params.text_document_position_params.
                }
            }
            Message::Response(resp) => {
...
\end{lstlisting}

If you'd like, take a minute to test this! Try initiating hover requests from various points within the sample file. Which fields of the params stay the same? Which change? You may have noted that we don't get a ton of information with each request. Looking at the spec, we can see the following:

% TODO: Typescript highlights
\begin{lstlisting}
interface HoverParams {
	textDocument: string; /** The text document's URI in string form */
	position: { line: uinteger; character: uinteger; };
}
\end{lstlisting}

This matches fairly closely with the type provides by the \texttt{lsp\_types} crate:

\begin{lstlisting}[language=rust]
pub struct HoverParams {
    pub text_document_position_params: TextDocumentPositionParams,
    pub work_done_progress_params: WorkDoneProgressParams,
}

pub struct TextDocumentPositionParams {
    /// The text document.
    pub text_document: TextDocumentIdentifier,

    /// The position inside the text document.
    pub position: Position,
}

pub struct TextDocumentIdentifier {
    pub uri: Url,
}

pub struct Position {
    /// Line position in a document (zero-based).
    pub line: u32,
    /// Character offset on a line in a document (zero-based).
    pub character: u32,
}
\end{lstlisting}

We have the cursor's position within the file, and the uri of the file itself. We can start by simply opening the file, going the specified postiion, and seeing what's there. ``Hey", you might be thinking, ``isn't I/O really slow? I want my LSP to be blazingly fast!". You would be right, but don't worry! We'll transition to a much faster means of accessing document contents later on. But for now, let's create a new \texttt{src/lsp.rs} file and add some new functionality! Our project's structure should look like the following now:

\lstset{escapeinside={<@}{@>}}
\begin{lstlisting}
<@\textcolor{blue}{assembly-lsp}@>
|--Cargo.lock
|--Cargo.toml
|--<@\textcolor{blue}{opcodes}@>
|  |--x86.xml
|--<@\textcolor{blue}{src}@>
   |--instruction.rs
   |--lib.rs
   |--lsp.rs
   |--main.rs
   |--populate.rs
\end{lstlisting}

And our newly created file should be the following:

\begin{lstlisting}[language=rust]
/* src/lsp.rs */
// TODO!
\end{lstlisting}

\subsection{Cleanup}

% Motivate having info

% Introduce the instruction info repo

% Introduce the register xml files from asm-lsp

% Sketch out structs for instructions and registers

% Quickly go over xml parsing functions

% Put in start up code

% Walk through the hoverrequest/ response interaction in detail
% go to spec
% sketch out according code
% Make improvements
