The time is now! We're finally adding a real feature to our LSP! We'll start by
adding hover support for instructions. A few things need to happen first though,
before we see that sweet sweet hover documentation window. First we need some
source of information for our instructions. This source needs to be in a fairly
organized, regular format fit for parsing. After finding such a source, we then
need to write some code to parse and load it into our program. This will require
some parsing code (duh), as well as some data structures to represent our information
once it's loaded from disk. Finally, we need to trigger every time a hover request
comes in from the client, check our relevant data structures, and return any results
we find in the right format. Without further ado, let's get started.

\subsection{Finding an Information Source}

The first thing we need is find some kind of data source for the x86\_64 instructions.
It should be well organized, reasonably convertible to some in-memory data structure,
and hopefully actively maintained (many active assembly languages receive regular
updates). Lucky for us, such a data source already exists! The open source
\href{https://github.com/Maratyszcza/Opcodes}{Opcodes} repo conveniently has both
the x86 and x86\_64 instruction sets in an xml file. Let's pull the appropriate
file into our project:

\begin{lstlisting}[language=bash]
mkdir opcodes && cd opcodes
curl https://github.com/Maratyszcza/Opcodes/blob/master/opcodes/x86.xml --output x86.xml
\end{lstlisting}

Our project should look two directories now (ignoring the \texttt{target} build
directory).

\lstset{escapeinside={<@}{@>}}
\begin{lstlisting}
<@\textcolor{blue}{assembly-lsp}@>
|--Cargo.lock
|--Cargo.toml
|--<@\textcolor{blue}{opcodes}@>
|  |--x86.xml
|--<@\textcolor{blue}{src}@>
   |--main.rs
\end{lstlisting}

Let's take a look inside that new file!

\begin{lstlisting}[language=xml]
<?xml version='1.0' encoding='utf-8'?>
<InstructionSet name="x86">
  <Instruction name="AAA" summary="ASCII Adjust After Addition">
    <InstructionForm gas-name="aaa" go-name="AAA">
      <Encoding>
        <Opcode byte="37"/>
      </Encoding>
    </InstructionForm>
  </Instruction>
  <Instruction name="AAD" summary="ASCII Adjust AX Before Division">
    <InstructionForm gas-name="aad" go-name="AAD">
      <Encoding>
        <Opcode byte="D5"/>
        <Opcode byte="0A"/>
      </Encoding>
    </InstructionForm>
    <InstructionForm gas-name="aad" go-name="AAD">
      <Operand type="imm8"/>
      <Encoding>
        <Opcode byte="D5"/>
        <Immediate size="1" value="#0"/>
      </Encoding>
    </InstructionForm>
  </Instruction>
  <Instruction name="AADD" summary="Atomically ADD">
  ...
\end{lstlisting}

It looks like each instruction has its name stored along with
a short summary. Nested inside each \texttt{<Instruction ...} there also appears
to be one or more instruction forms for the GNU Assembler (GAS) or the Go Assembler.
Each form has some more information included, such as the opcodes for that form,
the different arguments it can take, etc. How are we going to represent this data
inside our program?

\subsection{Data Structures and Parsing}

This calls for a new file! Let's create \texttt{src/instruction.rs} and start
laying out our data. Here's a start...

\begin{lstlisting}[language=rust]
pub struct Instruction {
    name: String,
    summary: String,
    ...
}
\end{lstlisting}

Those instruction forms seem fairly important, so let's create a struct to represent
them and then store a vector of forms inside each instruction. Given that there
are opcode files for both x86 and x86\_64, we should probably put some kind of
architecture information in there as well. Finally, we'll also derive some common
methods on these to make our lives easier down the road.

\begin{lstlisting}[language=rust]
#[derive(Debug, Clone, Default)]
pub struct Instruction {
    pub name: String,
    pub summary: String,
    pub arch: Option<Arch>,
    pub forms: Vec<InstructionForm>,
}

#[derive(Debug, Clone, Default)]
pub struct InstructionForm {
    pub gas_name: Option<String>,
    pub go_name: Option<String>,
    pub encoding: String,
    pub operands: Vec<Operand>
}

#[derive(Debug, Clone)]
pub struct Operand {
    pub op_type: OperandType,
    pub input: bool,
    pub output: bool,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy)]
pub enum Arch {
    x86,
    x86_64,
}
\end{lstlisting}

Writing out all of the variants for the \texttt{OperandType} enum looks really
annoying and tedious...luckily I've done it for you! For the sake of brevity,
I'll also take this time to introduce some new crates (\texttt{cargo add strum}
and \texttt{cargo add strum\_macros} when you have a minutes) to our project. We'll
use these dependencies to great effect while parsing and deserializing the \texttt{x86.xml}
file. Some operand types conflict with Rust's naming rules for its enum variants,
so in those cases I've changed the variant name to something reasonably close,
and then included the \texttt{\#[strum(serialize = "<ActualOpTypeHere>")]} macro
to make the translation possible. We'll also apply these helpers to our
\texttt{Arch} enum.

\begin{lstlisting}[language=rust]
use strum_macros::{AsRefStr, EnumString};

...

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, Copy, EnumString, AsRefStr)]
pub enum Arch {
    x86,
    x86_64,
}

#[allow(non_camel_case_types)]
#[derive(Debug, Clone, EnumString, AsRefStr)]
pub enum OperandType {
    #[strum(serialize = "1")]
    _1,
    #[strum(serialize = "3")]
    _3,
    imm4,
    imm8,
    imm16,
    imm32,
    imm64,
    al,
    cl,
    r8,
    r8l,
    ax,
    r16,
    r16l,
    eax,
    r32,
    r32l,
    rax,
    r64,
    mm,
    xmm0,
    xmm,
    #[strum(serialize = "xmm{k}")]
    xmm_k,
    #[strum(serialize = "xmm{k}{z}")]
    xmm_k_z,
    ymm,
    #[strum(serialize = "ymm{k}")]
    ymm_k,
    #[strum(serialize = "ymm{k}{z}")]
    ymm_k_z,
    zmm,
    #[strum(serialize = "zmm{k}")]
    zmm_k,
    #[strum(serialize = "zmm{k}{z}")]
    zmm_k_z,
    k,
    #[strum(serialize = "k{k}")]
    k_k,
    moffs32,
    moffs64,
    m,
    m8,
    m16,
    #[strum(serialize = "m16{k}")]
    m16_k,
    #[strum(serialize = "m16{k}{z}")]
    m16_k_z,
    m32,
    #[strum(serialize = "m32{k}")]
    m32_k,
    #[strum(serialize = "m32{k}{z}")]
    m32_k_z,
    #[strum(serialize = "m32/m16bcst")]
    m32_m16bcst,
    m64,
    #[strum(serialize = "m64{k}")]
    m64_k,
    #[strum(serialize = "m64{k}{z}")]
    m64_k_z,
    #[strum(serialize = "m64/m16bcst")]
    m64_m16bcst,
    m128,
    #[strum(serialize = "m128{k}")]
    m128_k,
    #[strum(serialize = "m128{k}{z}")]
    m128_k_z,
    m256,
    #[strum(serialize = "m256{k}")]
    m256_k,
    #[strum(serialize = "m256{k}{z}")]
    m256_k_z,
    m512,
    #[strum(serialize = "m512{k}")]
    m512_k,
    #[strum(serialize = "m512{k}{z}")]
    m512_k_z,
    #[strum(serialize = "m64/m32bcst")]
    m64_m32bcst,
    #[strum(serialize = "m128/m32bcst")]
    m128_m32bcst,
    #[strum(serialize = "m256/m32bcst")]
    m256_m32bcst,
    #[strum(serialize = "m512/m32bcst")]
    m512_m32bcst,
    #[strum(serialize = "m128/m16bcst")]
    m128_m16bcst,
    #[strum(serialize = "m128/m64bcst")]
    m128_m64bcst,
    #[strum(serialize = "m256/m16bcst")]
    m256_m16bcst,
    #[strum(serialize = "m256/m64bcst")]
    m256_m64bcst,
    #[strum(serialize = "m512/m16bcst")]
    m512_m16bcst,
    #[strum(serialize = "m512/m64bcst")]
    m512_m64bcst,
    vm32x,
    #[strum(serialize = "vm32x{k}")]
    vm32x_k,
    vm64x,
    #[strum(serialize = "vm64x{k}")]
    vm64xk,
    vm32y,
    #[strum(serialize = "vm32y{k}")]
    vm32yk_,
    vm64y,
    #[strum(serialize = "vm64y{k}")]
    vm64y_k,
    vm32z,
    #[strum(serialize = "vm32z{k}")]
    vm32z_k,
    vm64z,
    #[strum(serialize = "vm64z{k}")]
    vm64z_k,
    rel8,
    rel32,
    #[strum(serialize = "{er}")]
    er,
    #[strum(serialize = "{sae}")]
    sae,
    sibmem,
    tmm, 
}
\end{lstlisting}

\subsection{Information Loading}

Great! Now we have a bunch of data in our xml file, and we have some places to put
all that data with our above data structures! Now we just need to actually \textit{put}
the data in the structs. Again, we're focusing on LSPs here! I'll spare the reader
from what would have most certainly been an eloquent, flowing explanation and
instead present the code with a brief explanation after. We'll add a new dependency
with \texttt{cargo add quick-xml}, and then start with a fresh file \texttt{src/populate.rs},
we have...

\begin{lstlisting}[language=rust]
// TODO
\end{lstlisting}

This is a fair amount of code, but most of it is fairly straightforward. The
\texttt{quick-xml} crate allows for event-based reading. Each opening
\texttt{<Instruction name=``...} goes right along with an \texttt{Event::Start()}
with the reader. Similarly, each closing \texttt{</Instruction>} pairs with a
corresponding \texttt{Event::End()}. The qualified name (\texttt{QName()}) allows
us to distinguish between events for \texttt{Instruction}s, \texttt{InstructionForm}s,
and other pieces of information. A new \texttt{Instruction} struct is created with
each starting event, its fields are filled in, and the struct is moved into a
\texttt{HashMap} on a closing event. The same goes for \texttt{InstructionForm}s,
except on close the form is appended to the current \texttt{Instruction}'s
\texttt{forms} field.

Those who gave the code a quick glance may have noticed
the alarming amount of \texttt{unsafe\{ \}} blocks the code uses. Isn't unsafe
code bad? Aren't we risking frequent crashes and an unreliable end product? Well,
not really. This piece of code runs once (maybe a handful of times once we get
further into the project) at startup and that's it. The function's input (our xml
file) will rarely or never change. Once everything is working today, we can rest
assured that it will also work tomorrow. We could \textit{definitely} write this
without any \texttt{unsafe\{ \}} blocks by simply replacing 
\texttt{str::from\_utf8\_unchecked()} with \texttt{str::from\_utf8()} and handling
any errors appropriately. Using the unchecked variant gives a performance boost,
however, as the code doesn't check to make sure that the string contains valid
UTF-8 first. This boost translates into our server reaching full-functionality
faster after starting, which will translate directly into a better user experience.
I took the time to measure the two (which you should do for \textit{any} performance
work!) and found a definite, albeit small performance boost for the unsafe version.
Given that it adds little to no extra complexity, we'll take it!

Potentially dubious performance claims aside, let's continue! Let's take that code
we just wrote and put it to use. 

\subsection{Hover Requests}

\subsection{Cleanup}

% Motivate having info

% Introduce the instruction info repo

% Introduce the register xml files from asm-lsp

% Sketch out structs for instructions and registers

% Quickly go over xml parsing functions

% Put in start up code

% Walk through the hoverrequest/ response interaction in detail
% go to spec
% sketch out according code
% Make improvements
