All of the finished code for each chapter can be found in the \href{\URL}{book's repo}. 
With that being said, let's get started!

\subsection{Dependencies}

As with nearly any other Rust project, we can start by creating a new project with
cargo: \texttt{cargo new assembly-lsp}. We'll add some dependencies next:

\begin{itemize}
	\item \texttt{cargo add crossbeam-channel}
	      \begin{itemize}
		      \item Handles sending and receiving data across channels so our LSP server
		            can talk to our editor's LSP client
	      \end{itemize}
	\item \texttt{cargo add flexi\_logger}
	      \begin{itemize}
		      \item Allows for some easy structured logging over \texttt{stderr}.
	      \end{itemize}
	\item \texttt{cargo add log}
	      \begin{itemize}
		      \item Another logging crate we'll use
	      \end{itemize}
	\item \texttt{cargo add lsp-server}
	      \begin{itemize}
		      \item Handles the majority of LSP-related things for us. This crate
		            lets us focus on features, rather than implementing a spec.
	      \end{itemize}
	\item \texttt{cargo add lsp-types}
	      \begin{itemize}
		      \item The LSP spec includes a fair number of type defitinitions, which
		            are (unfortunately) in Typescript. This crate provides Rust versions
		            of the spec's types that adhere to the spec.
	      \end{itemize}
	\item \texttt{cargo add serde --features derive}
	      \begin{itemize}
		      \item This amazing crate is part of nearly every Rust project, including
		            ours too.
	      \end{itemize}
	\item \texttt{cargo add serde\_json}
	      \begin{itemize}
		      \item LSP servers and clients communicate over JSON RPC. Naturally this
		            crate will be of use.
	      \end{itemize}
\end{itemize}

\subsection{Starting Code}

Now that the scaffolding is in place, we can finally get to coding. A great template
can be found in the rust-analyzer (the absolutely excellent Rust LSP)
\href{https://github.com/rust-lang/rust-analyzer/tree/master/lib/lsp-server}{repo}.
Their example starts out with some code for the go to definition capability. We'll
get there eventually, but our starting point is different. Here's the stripped down code:

\begin{lstlisting}[language=rust]
use log::info;
use lsp_server::{Connection, ExtractError, Message, Request, RequestId};
use lsp_types::{InitializeParams, ServerCapabilities};

fn main() -> anyhow::Result<()> {
    // Set up logging. Because `stdio_transport` gets a lock on stdout and stdin, we must have our
    // logging only write out to stderr.
    flexi_logger::Logger::try_with_str("info")?.start()?;

    info!("Starting assembly-lsp");

    // Create the transport. Includes the stdio (stdin and stdout) versions but this could
    // also be implemented to use sockets or HTTP.
    let (connection, io_threads) = Connection::stdio();

    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).
    let server_capabilities = serde_json::to_value(&ServerCapabilities {
        ..Default::default()
    })
    .unwrap();

    let initialization_params = connection.initialize(server_capabilities)?;

    main_loop(connection, initialization_params)?;
    io_threads.join()?;

    // Shut down gracefully.
    info!("Shutting down assembly-lsp");
    Ok(())
}

fn main_loop(connection: Connection, params: serde_json::Value) -> anyhow::Result<()> {
    let _params: InitializeParams = serde_json::from_value(params).unwrap();
    info!("Entering main loop");
    for msg in &connection.receiver {
        eprintln!("got msg: {msg:?}");
        match msg {
            Message::Request(req) => {
                if connection.handle_shutdown(&req)? {
                    return Ok(());
                }
                info!("Got request: {req:?}");
            }
            Message::Response(resp) => {
                info!("Got response: {resp:?}");
            }
            Message::Notification(notif) => {
                info!("Got notification: {notif:?}");
            }
        }
    }
    Ok(())
}

fn cast_req<R>(req: Request) -> Result<(RequestId, R::Params), ExtractError<Request>>
where
    R: lsp_types::request::Request,
    R::Params: serde::de::DeserializeOwned,
{
    req.extract(R::METHOD)
}
\end{lstlisting}

There's nothing too crazy here, but it'll help to unpack everything briefly. Let's
start from the top! The first thing we do is set up our logging. As the LSP protocol
uses \texttt{stdout} for client-server communication, we configure our logger to
use \texttt{stderr}. Next we use the \texttt{lsp-server} crate to open a connection
between the LSP server (our program) and an LSP Client (likely a text editor).

Next we have an object to specify our server capabilities to the client. If you've
taken a look at the \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/}{LSP spec},
you probably noticed a large number of capabilities. The great thing about the LSP
spec is that we only have to implement the capabilities we want to. From the \href{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#capabilities}{docs}:

\begin{center}
	``Not every language server can support all features defined by the protocol.
	LSP therefore provides ‘capabilities’. A capability groups a set of language
	features."
\end{center}

The capabilities are all optional, and if look at the \texttt{lsp-types} crate, we can see
that every capability-related type is of type \texttt{Option<T>}. As the default
value for any \texttt{Option} type is \texttt{None}, we can safely specify the
capabilities we care about, and ignore all the others.

With our (currently empty) capabilities defined via \texttt{server\_capabilities},
we communicate them via the `initialize` request and receive client's capabilities
back in turn. With this handshake out of the way, we then enter the meat of the program,
which is just a simple event loop to receive and respond to requests from the client.
Rust's pattern matching really shines here, letting us easily break down our server's
actions by the type of message its received. Our event loop doesn't do anything
besides print out the messages it receives. At this point it would probably be useful
to test things out and make sure the program is behaving as expected. While we'd
normally just test the things by running the LSP with our editor of choice, for
pedagogical purposes it can be useful to see how things work manually. If we run
our server from the command line, (with a little help from \texttt{sed} we can act
as the LSP client and manually enter JSON RPC messages. Starting with

\begin{lstlisting}[language=bash]
    sed -u -re 's/^(.*)$/\1\r/' | cargo run
\end{lstlisting}

we should see our program build and then start. Entering

\begin{lstlisting}
Content-Length: 85

{"jsonrpc": "2.0", "method": "initialize", "id": 1, "params": {"capabilities": {}}}
\end{lstlisting}

followed by

\begin{lstlisting}
Content-Length: 59

{"jsonrpc": "2.0", "method": "initialized", "params": {}}
\end{lstlisting}

will give our server enough information to enter into it's event loop. This isn't
a good way to interact with or test the, but it's helpful to peel back the curtain
at times and see that this isn't magic. It really is just JSON RPC over \texttt{stdout}.
We can wrap things up by sending shutdown and exit requests.

\begin{lstlisting}
Content-Length: 67

{"jsonrpc": "2.0", "method": "shutdown", "id": 3, "params": null}
\end{lstlisting}

followed by

\begin{lstlisting}
Content-Length: 54

{"jsonrpc": "2.0", "method": "exit", "params": null}
\end{lstlisting}

All of this together:

%\lstset{escapeinside={<@}{@>}}
%<@\textcolor{COLOR}{TEXT}@>
\begin{lstlisting}[language=bash]
$ sed -u -re 's/^(.*)$/\1\r/' | cargo run

Compiling assembly-lsp v0.1.0 (/home/lillis/projects/LSPBook/assembly-lsp)
warning: function `cast_req` is never used
  --> src/main.rs:55:4
   |
55 | fn cast_req<R>(req: Request) -> Result<(RequestId, R::Params), ExtractError<Request>>
   |    ^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: `assembly-lsp` (bin "assembly-lsp") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 1.30s
     Running `target/debug/assembly-lsp`
INFO [assembly_lsp] Starting assembly-lsp
Content-Length: 85

{"jsonrpc": "2.0", "method": "initialize", "id": 1, "params": {"capabilities": {}}}
Content-Length: 53

{"jsonrpc":"2.0","id":1,"result":{"capabilities":{}}}Content-Length: 59

{"jsonrpc": "2.0", "method": "initialized", "params": {}}
INFO [assembly_lsp] Entering main loop
Content-Length: 67

{"jsonrpc": "2.0", "method": "shutdown", "id": 3, "params": null}
got msg: Request(Request { id: RequestId(I32(3)), method: "shutdown", params: Null })
Content-Length: 38

{"jsonrpc":"2.0","id":3,"result":null}Content-Length: 54

{"jsonrpc": "2.0", "method": "exit", "params": null}
INFO [assembly_lsp] Shutting down assembly-lsp
$
\end{lstlisting}

Finally, underneath the main loop we have a small helper function
\texttt{cast\_req}. Depending on your experience level with Rust, this function signature
may look a little scary, but I promise it's not. Per the LSP spec, the parameters
passed along with each request all have distinct types. The trait bounds used in
the function's signature simply allows it to take in a request and return the correct
parameter type.

\subsection{LSP to Editor Connection}

Now that most of the boilerplate-y code is in place, let's connect
our server to our editor. This process can vary greatly from editor to editor.

I personally use Neovim, and would highly reccomend it to anyone interested in
creating their own \href{https://www.youtube.com/watch?v=QMVIJhC9Veg}{Personal Development Environment}.
However with it being a very personalized editor, methods for attaching a new LSP
can cary greatly depending on one's config. For the purposes of this book however,
we want to focus on LSPs, not finding the right \st{incantation} set of configuration
options to make the two processes connect. I've gone through this process for a few
editors, and found Sublime's setup to be the easiest \textit{by far}. I would highly
encourage you to set up the LSP in your editor of choice. However, in the interest
of having some guaranteed way to test things, I'll go through the sublime setup below.
I've included the specific steps I followed on my Ubuntu system, but if that doesn't
work I've also provided links to the relevant documentation.

\begin{enumerate}
	\item Install \href{https://www.sublimetext.com/}{Sublime Text} if you don't already have it
	      \begin{itemize}
		      \item For me, this was just \texttt{sudo apt-get install sublime-text}
	      \end{itemize}
      \item Install Sublime's \href{https://github.com/sublimelsp/LSP}{LSP} client
	      \begin{itemize}
		      \item Open Sublime
		      \item Open the command pallet (default is Control+Shift+p)
		      \item Run \texttt{Package Control: Install Package}
		      \item Select \texttt{LSP}
	      \end{itemize}
    \item Ensure the executable produced for our program can be found on the system \texttt{PATH}
	\item Configure Sublime to work with our LSP
	      \begin{itemize}
		      \item Open the command pallet (default is Control+Shift+p)
		      \item Run \texttt{Package Control: Install Package}
		      \item Select the \href{https://packagecontrol.io/packages/x86\%20and\%20x86_64\%20Assembly}{x86 and x86\_64 Assembly} package
		      \item Open \texttt{Preferences > Package Settings > LSP > Settings} and add the ``\texttt{assembly-lsp}" client configuration to the ``\texttt{clients}":
	      \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=json]
{
    "clients": {
        "assembly-lsp": {
            "enabled": true,
            "command": ["assembly-lsp"],
            "selector": "source.asm | source.assembly"
        }
    }
}
\end{lstlisting}

...And that should be it! We can make sure things are working by opening the project's
test file in Sublime and checking the logs (\texttt{Tools > LSP > Toggle Log Panel}). 
We should see the same logs we added earlier, as well as the messages exchanged as
part of the protocol. That's all the setup we'll do for now, let's get started on our
first feature!

% Setup
% Include instructions for major text editors
% Neovim
% Sublime-> This may be best...
% Vscode????

% Reading data in from xml
% Hover support
% Just instructions?

% Extend to registers?

% Ok what about autocomplete
% give motivation for tree-sitter
% recursive approach first
% tree-sitter queries
% implement it for instructions and registers

% Work in textdoc syncing, first FULL
% Then expand to incremental, compliment rust ecosystem

% Throughout the book, give possible ways the reader could expand
% the feature

% At this point, the hard part is over!
% Chapters/ subsections with smaller features to add

% refer to spec throughout to help figure out request, response
